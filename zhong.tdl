;;; -*- Mode: TDL; Coding: utf-8 -*-

;;; Zhong [|] Grammar
;;;
;;; created at:
;;;     Tue Jun 30 19:43:27 UTC 2009
;;; based on Matrix customization system version of:
;;;     Tue Jun 23 20:36:41 UTC 2009
;;;
;;; Authors: Nat Hillard, Dan Flickinger, Chunlei Yang
;;;


;; SSH 2014-09-04: Teh style feature for efficient generation
sign :+
 [ STYLE style,
   IDIOMATIC luk ].

;;; STYLE
style := avm & 
 [ WRITTEN luk ].
strict := style &
 [ WRITTEN + ].
robust := style.
spoken := robust & 
 [ WRITTEN - ].
unproductive := robust.
dialect := robust. 

lex-rule :+ 
 [ STYLE #style,
   DTR.STYLE #style ].

basic-unary-phrase :+ 
  [ STYLE #style,
    SYNSEM.PAREN #paren,
    ARGS < [ STYLE #style,
	     SYNSEM.PAREN #paren ] > ].


;; SSH 2014-12-19: BOUND is introduced. Lexical items with [BOUND +]
;; cannot be combined with the other of itself.
;; CH to indicate the position of COMPS, CH+ means COMP before HEAD, CH- means COMP after HEAD, allowing HEAD to have one COMP before and one COMP after
synsem :+ 
 [ PUNCTUATED luk,
   INTERJECTED luk,
   PAREN luk,
   ASPECTED luk,
   POSTCOMP luk,
   CH luk,
   BARE luk,
   SPART spart,
   UTTERED luk,
   BOUND luk ].

spart := avm.
not-crs := spart.
not-ma := spart.
crs := not-ma.
ma := not-crs.
no-spart := spart.
not-crs-not-ma := not-crs & not-ma.


;; SSH 2014-10-24: for chart mapping
;; MATRIX REDEFINITION
;; make STEM of type orthog(raphy) to pass up from/to/form
sign-min := avm &
  [ STEM orthog ].

orthog := cons &
  [ FROM string,
    TO string ].


;; SSH 2015-01-26: compound lexical items
cpd := icons.
;noun-noun := cpd.
pred-pred := cpd. 
rslt := pred-pred.
parallel := pred-pred.

card_rel := named_rel.
symbol_rel := named_rel.

card-relation := named-relation & arg1-relation &
  [ PRED card_rel ].

symbol-relation := named-relation & arg1-relation &
  [ PRED symbol_rel ].


q_rel := predsort.
every_q_rel := q_rel.
exist_q_rel := q_rel.
some_q_rel := exist_q_rel.
proper_q_rel := q_rel.
pronoun_q_rel := q_rel.
which_q_rel := q_rel.
generic_q_rel := q_rel.

related_p_rel := predsort.
compound_p_rel := related_p_rel.
;poss_p_rel := related_p_rel.

demons_rel := predsort.
prox_demons_rel := demons_rel.
dist_demons_rel := demons_rel.

pron_rel := predsort.
generic_n_rel := predsort.
vp_ellipsis_rel := predsort.

cl_x_rel := predsort.

intensifier_x_rel := predsort.
redup_x_rel := intensifier_x_rel.

neg_x_rel := predsort.
nm_rel := predsort.
measure_x_rel := predsort.
bridge_x_rel := predsort.

time_p_rel := predsort.

+vj :+ 
   [ STATIVE luk,
     PRED-KEY predsort ].

char := avm & 
  [ FCHAR string, 
    WCHAR string, 
    LENGTH length ].

length := avm.
one-or-two := length.
more-than-one := length.
one := one-or-two.
two := one-or-two & more-than-one.
more-than-two := more-than-one.



;; WWJ 2015-04-07: EXISTV for 有; MODIFIABLE used 
;; for A-elements in A-not-A structures
;; ZZF & FB 2016-10-3: EMPTY for phrases created by rule with an empty head
head :+
 [ EMPTY bool,
   CHAR char,
   EXISTV bool, 
   MODIFIABLE bool,
   MEASURE luk ].

lex-item :+ 
 [ STEM.FIRST #str,
   SYNSEM.LOCAL.CAT.HEAD.CHAR.WCHAR #str ].

marker-or-punct := head & 
 [ MOD <> ].
marker := marker-or-punct.
punct := marker-or-punct.

+np :+ [ PFORM pform ].
pform := avm.
gei-or-xiang := pform.
gei := gei-or-xiang.
xiang := gei-or-xiang.
zai := pform.
you := pform.
dui := pform.

+njd :+ 
 [ HON luk,
   GENERIC luk,
   CLASSIFIED luk ].

;; SSH 2014-10-10 nominalizer 的 'de'
nm := noun.

num :+ 
 [ CARDINAL bool ].


;; SSH 2015-04-16: The following are revised. 
prep := adp.
postp := adp.
postp-assoc := postp.
postp-assoc-n := postp-assoc & postp-nominalizable.
postp-assoc-v := postp-assoc.
postp-nominalizable := postp.
postp-comp := postp-nominalizable.


;; SSH 2014-09-02: Gender is necessary to distinguish he and she. 
;; 她 追赶 了 他: She chased him.
;; In addition, Animacy is also neceesary to disinguish s(he) and it.
;; 她 追赶 了 它: She chasd it.
png :+ 
  [ PERNUM pernum,
    GENDER gender,
    ANIMACY animacy ].

;;; Pernum

pernum := *top*.
sg := pernum.
indet := pernum.
pl := pernum.
1st := pernum.
2nd := pernum.
3rd := pernum.
1sg := 1st & sg.
2sg := 2nd & sg.
3sg := 3rd & sg.
1indet := 1st & indet.
2indet := 2nd & indet.
3indet := 3rd & indet.
1pl := 1st & pl.
1pl_incl := 1pl.
1pl_excl := 1pl.
2pl := 2nd & pl.
3pl := 3rd & pl.

;;; SSH 2014-09-02
;;; Gender 
gender := *top*.
masc := gender.
fem := gender.

;;; SSH 2014-09-02; 2015-04-08 revised 
;;; Animacy
animacy := *top*.
animate := animacy.
human := animate.
non-human := animate.
inanimate := animacy.

;;; Form

form := *top*.
nonfinite := form.
finite := form.

;;; Aspect


;; SSH/ZZF 2015-04-29: [tentative := aspect.] should be reviewed.
;has-aspect := aspect.
perf-or-exp := aspect.
durative := aspect.
delimitative := aspect.
tentative := aspect.
;; SSH 2014-09-19: The type hierarchy for aspect should be researched
;; more. We assume here that no-marking implies *imperfective*.
;; 2016-2-15 ZZF changing experiential (guo) from "imperfective" to "perfective" ::fix me
imperfective := aspect.
perfective := perf-or-exp.
experiential := perf-or-exp.
;; SSH 2014-09-04; blocking overgeneration
non-aspect := imperfective.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SSH 2015-05-24
;; CTXT (Honorification)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

dialogue := icons.
addressor := dialogue.
addressee := dialogue.
rank := icons.
higher-or-equal := rank.
lower-or-equal := rank.
higher := higher-or-equal.
lower := lower-or-equal.
equal :=  higher-or-equal & lower-or-equal.

ctxt :+ [ C-INDICES c-indices ].

c-indices := avm & 
  [ SPEAKER ref-ind,
    HEARER ref-ind ].

;;; Phrasal types

head-only :+ 
  [ SYNSEM.LOCAL.CAT [ NONSUBJ #ns,
		       NONCOMP #nc ], 
    HEAD-DTR.SYNSEM.LOCAL.CAT [ NONSUBJ #ns,
				NONCOMP #nc ] ]. 


basic-head-comp-phrase :+ 
  [ SYNSEM.LOCAL.CAT [ MC #mc,
		       VAL.SPEC #spec ],
    HEAD-DTR.SYNSEM [ BOUND na-or--,
		      LOCAL.CAT [ MC #mc,
				  VAL.SPEC #spec ] ] ].


basic-head-comp-phrase :+ [ SYNSEM.LOCAL.CAT.NONCOMP #nc,
                      HEAD-DTR.SYNSEM.LOCAL.CAT.NONCOMP #nc ].

;;2016-2-19 ZZF FB SSH copy SPEC from HEAD-DTR to mother.
basic-head-mod-phrase-simple :+ 
  [ SYNSEM.LOCAL [ CAT [ MC #mc,
                         VAL.SPEC #spec ],
		   CONT.HOOK.INDEX #ind ],
    HEAD-DTR.SYNSEM.LOCAL [ CONT.HOOK.INDEX #ind,
                            CAT.VAL.SPEC #spec ],
    NON-HEAD-DTR.SYNSEM [ PUNCTUATED na-or--,
			  LOCAL.CAT.MC #mc ] ].



; SSH 2014-08-25 Zhong specific head-adj-phrase This consraint was in
; the previous version of matrix.tdl, but it was removed by Antske
; Fokkens and Joshua Crowgey (2012-26-09).
head-adj-phrase :+ 
  [ SYNSEM.INTERJECTED #interjected,
    HEAD-DTR.SYNSEM [ INTERJECTED #interjected,
		      MODIFIED notmod-or-rmod ] ].

head-adj-int-phrase :+ 
"Using OPT on non-head-dtr to prevent a special DeP from being taken as a normal modifier.
"
  [ SYNSEM [ L-PERIPH #lperiph,
	     R-PERIPH #rperiph ],
    HEAD-DTR.SYNSEM.R-PERIPH na-or--,
    NON-HEAD-DTR.SYNSEM [ L-PERIPH #lperiph,
			  R-PERIPH #rperiph,
                          LOCAL.CAT.HEAD.MOD < [ OPT na-or-- ] > ] ].

;; WWJ (2015-03-28): NHD's SPART and Phrase's NHD are identi-fied... is this ok?
head-adj-scop-phrase :+
  [ SYNSEM.SPART #spart,
    HEAD-DTR.SYNSEM.ASPECTED +-or--,
    NON-HEAD-DTR.SYNSEM [ BOUND -, 
                          SPART #spart ] ].

;; The head of head-comp-phrase can't be: ['comp']

head-comp-phrase := basic-head-1st-comp-phrase & head-initial &
  [ SYNSEM phr-synsem &
       [ LOCAL.CAT.HEAD +nvjrpdmo ],
    HEAD-DTR.SYNSEM.POSTCOMP na-or--,
    NON-HEAD-DTR.SYNSEM [ R-PERIPH na-or--,
			  INTERJECTED na-or--,
                          CH na-or-- ] ].
#|
;;2016-2-15 ZZF FB separating head-comp for verbs and adjectives, comp node's SPR is "olist" means either unexpressed or saturated
hdv-comp-phrase := head-comp-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD verb,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR olist ].

hdnonv-comp-phrase := head-comp-phrase &
  [ SYNSEM.LOCAL.CAT.HEAD +njrpdmo ].
|#
;; WWJ (2015-03-28) - HEAD-DTR's spart value is passed up to this phrase
head-comp-phrase :+
  [ SYNSEM.SPART #spart,
    HEAD-DTR.SYNSEM.SPART #spart,
    NON-HEAD-DTR.SYNSEM.BOUND - ].

;; SSH/ZZF 2015-07-15
head-comp-phrase :+ [ SYNSEM.LOCAL.CAT.NONCOMP #nc,
                      HEAD-DTR.SYNSEM.LOCAL.CAT.NONCOMP #nc ]. 
;; to allow 0-1-dlist                      SYNSEM.NON-LOCAL.SLASH 0-dlist ].


;; SSH 2015-04-16: adp -> prep
head-2nd-comp-phrase := basic-head-2nd-comp-phrase & head-initial &
  [ SYNSEM phr-synsem &
       [ LOCAL.CAT.HEAD verb ],
    HEAD-DTR.SYNSEM.POSTCOMP na-or--,
    NON-HEAD-DTR.SYNSEM [ LOCAL.CAT.HEAD prep,
                          R-PERIPH na-or--,
			  INTERJECTED na-or-- ] ]. 

;; SSH 2015-04-16: adp -> +np (ex. 我 [教室 里] 哭 了)
comp-head-final-phrase := basic-head-1st-comp-phrase & head-final & 
"POSTCOMP + == I'm after my comps
"
  [ SYNSEM.LOCAL.CAT.HEAD +njrpdmo,
    HEAD-DTR.SYNSEM.POSTCOMP +,
    NON-HEAD-DTR.SYNSEM [ R-PERIPH na-or--,
                          CH na-or-+,
			  LOCAL.CAT.HEAD +nvjp ] ].

;; For now, exclude time nouns as subjects
;; 
;; SSH 2014-09-26: Only phrases can be the subjects (phr-synsem)
;; SSH 2015-07-13: non-rel subj-head and rel subj-head (nonmc)
;;                 Added [NON-LOCAL.SLASH 0-dlist]
;; ZZF FB 2016-2-24: changed subj's SPR to be olist
subj-head-phrase := decl-head-subj-phrase & head-final &
  [ SYNSEM.LOCAL.CAT.MC #mc,
    SYNSEM.SPART #spart,
    HEAD-DTR.SYNSEM [ LOCAL.CAT [ MC #mc,
				  VAL [ SPR < >,
				      COMPS < > ],
				  POSTHEAD + ],
                      SPART #spart,
		      NON-LOCAL.SLASH 0-1-dlist ],
    NON-HEAD-DTR.SYNSEM  [ R-PERIPH na-or--,
			   INTERJECTED na-or--,
			   LOCAL [ CAT [ MC +,
					 NONSUBJ -,
					 VAL.SPR olist ],
				   CONT.HOOK.INDEX.SORT nontime-s ],
			   NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
				       REL 0-dlist ] ] ].
#|
nmc-subj-head-phrase := basic-head-subj-phrase & head-final &
  [ SYNSEM.LOCAL.CAT.MC -,
    SYNSEM.SPART #spart,
    HEAD-DTR.SYNSEM.LOCAL.CAT [ VAL [ SPR olist,
				      COMPS < > ],
				POSTHEAD + ],
    HEAD-DTR.SYNSEM [ SPART #spart,
		      NON-LOCAL.SLASH 1-dlist ],
    NON-HEAD-DTR.SYNSEM  [ R-PERIPH na-or--,
			   INTERJECTED na-or--,
			   LOCAL [ CAT [ MC +,
					 NONSUBJ -,
					 HEAD.GENERIC na-or--,
					 VAL.SPR <> ],
				   CONT.HOOK.INDEX.SORT nontime-s ],
			   NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
				       REL 0-dlist ] ] ].
|#            
;; comp-head-phrase requires things that are [ HEAD comp ].
;; SSH 2015-07-13: relative-clauses
comp-head-phrase := basic-head-1st-comp-phrase & head-final &
  [ SYNSEM [ LOCAL.CAT.HEAD comp,
	     NON-LOCAL.SLASH #slash ],
    NON-HEAD-DTR [ STYLE strict,
		   SYNSEM [ R-PERIPH na-or--,
			    INTERJECTED na-or--,
			    BOUND na-or--,
			    NON-LOCAL.SLASH #slash ] ] ].

#|
relative-clause := binary-phrase & phrasal & head-compositional & head-final &
  [ SYNSEM [ LOCAL [ CAT [ VAL [ COMPS < >,
                                 SPR < > ] ] ],
			 NON-LOCAL.SLASH 0-dlist ],
    NON-HEAD-DTR [ SYNSEM [ LOCAL [ CAT [ HEAD comp,
					  VAL.COMPS olist ],
				    CONT.HOOK.INDEX #clause ],
			    NON-LOCAL [ SLASH 1-dlist &
					      [ LIST [ FIRST #slash,
						       REST < > & #last ],
						LAST #last ],
					QUE 0-dlist,
					REL 0-dlist ] ] ], 
    HEAD-DTR [ SYNSEM canonical-synsem &
	       [ LOCAL #slash & local &
			      [ CAT [ HEAD noun & [ GENERIC na-or-- ],
				      VAL [ SUBJ olist,
					    COMPS olist,
					    SPR olist ] ],
				CONT.HOOK #hook & [ INDEX #target ],
				CTXT.ACTIVATED + ],
			NON-LOCAL.SLASH 0-dlist ] ],
    C-CONT [ HOOK #hook,
	     RELS <! !>,
	     HCONS <! !>,
	     ICONS <! focus-or-topic & [ IARG1 #clause,
                                         IARG2 #target ] !> ] ].
|#

;; MATRIX REDEFINITION
;; SSH 2015-05-07: x_rel and q_rel are defined as types.
n-coord-phrase :+
[ SYNSEM.LOCAL.CONT.HOOk.INDEX.SORT #sort,
  LCOORD-DTR.SYNSEM.LOCAL.CONT.HOOk.INDEX.SORT #sort ].

np-coord-phrase :+
[ SYNSEM.LOCAL.CONT.HOOk.INDEX.SORT #sort,
  LCOORD-DTR.SYNSEM.LOCAL.CONT.HOOk.INDEX.SORT #sort ].

basic-np-top-coord-rule := np-coord-phrase &
  [ SYNSEM.LOCAL.CAT.VAL.SPR < >,
    C-CONT [ HOOK [ LTOP #ltop,
                    INDEX #ind ],
             RELS <! [ PRED exist_q_rel, ARG0 #ind, RSTR #ltop ] !>,
	     HCONS <! !> ]].

s-coord-phrase :+ 
[ SYNSEM.LOCAL.CAT.MC #mc,
  LCOORD-DTR.SYNSEM.LOCAL.CAT.MC #mc,
  RCOORD-DTR.SYNSEM.LOCAL.CAT.MC #mc ].
 

;;; Coordination Strategy 1

n1-top-coord-rule := basic-np-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

n1-mid-coord-rule := basic-np-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

#|
n1-bottom-coord-rule := infl-bottom-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1",
    SYNSEM.LOCAL.COORD-REL.PRED "_and_coord_rel",
    DTR.SYNSEM.LOCAL.CAT.HEAD noun ].
|#

bottom-coord-rule := conj-first-bottom-coord-rule &
  [ SYNSEM [ LOCAL [ CAT.HEAD #head,
                     COORD + ],
             NON-LOCAL #nonloc ],
    CONJ-DTR.SYNSEM.LOCAL.CAT.HEAD conj,
    NONCONJ-DTR.SYNSEM [ LOCAL.CAT.HEAD #head,
                         NON-LOCAL #nonloc ] ].


;;; Coordination Strategy 2

vp1-top-coord-rule := basic-vp-top-coord-rule & apoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

#|
vp1-bottom-coord-rule := conj-first-bottom-coord-rule & 
             vp-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].
|#

;;; Coordination Strategy 3

n3-top-coord-rule := basic-n-top-coord-rule & apoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "3" ].

n3-bottom-coord-rule := unary-bottom-coord-rule & n-bottom-coord-phrase &
  [ SYNSEM.LOCAL [ COORD-STRAT "3",
                   COORD-REL.PRED "_and_coord_rel" ] ].

;;; Coordination Strategy 3

np3-top-coord-rule := basic-np-top-coord-rule & apoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "3" ].

np3-bottom-coord-rule := unary-bottom-coord-rule & np-bottom-coord-phrase &
  [ SYNSEM.LOCAL [ COORD-STRAT "3",
                   COORD-REL.PRED "_and_coord_rel" ] ].

;;; Coordination Strategy 3

vp3-top-coord-rule := basic-vp-top-coord-rule & apoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "3" ].

vp3-bottom-coord-rule := unary-bottom-coord-rule & vp-bottom-coord-phrase &
  [ SYNSEM.LOCAL [ COORD-STRAT "3",
                   COORD-REL.PRED "_and_coord_rel" ] ].

;;; Coordination Strategy 3

s1-top-coord-rule := basic-s-top-coord-rule & apoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "1" ].

#|
s3-bottom-coord-rule := unary-bottom-coord-rule & s-bottom-coord-phrase &
  [ SYNSEM.LOCAL [ COORD-STRAT "1",
                   COORD-REL.PRED "_and_coord_rel" ] ].
|#

;;; Coordination Strategy 4

n4-top-coord-rule := basic-n-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "4" ].

n4-mid-coord-rule := basic-n-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "4" ].

n4-bottom-coord-rule := infl-bottom-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "4",
    SYNSEM.LOCAL.COORD-REL.PRED "_and_coord_rel",
    DTR.SYNSEM.LOCAL.CAT.HEAD noun ].

;;; Coordination Strategy 5

n5-top-coord-rule := basic-n-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "5" ].

n5-mid-coord-rule := basic-n-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "5" ].

n5-bottom-coord-rule := conj-first-bottom-coord-rule & n-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "5" ].

;;; Coordination Strategy 5

np5-top-coord-rule := basic-np-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "5" ].

np5-mid-coord-rule := basic-np-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "5" ].

np5-bottom-coord-rule := conj-first-bottom-coord-rule & 
             np-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "5" ].

;;; Coordination Strategy 5

vp5-top-coord-rule := basic-vp-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "5" ].

vp5-mid-coord-rule := basic-vp-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "5" ].

vp5-bottom-coord-rule := conj-first-bottom-coord-rule & 
             vp-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "5" ].

;;; Coordination Strategy 5

s5-top-coord-rule := basic-s-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "5" ].

s5-mid-coord-rule := basic-s-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "5" ].

s5-bottom-coord-rule := conj-first-bottom-coord-rule & s-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "5" ].

;;; Coordination Strategy 6

s6-top-coord-rule := basic-s-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "6" ].

s6-mid-coord-rule := basic-s-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "6" ].

s6-bottom-coord-rule := conj-first-bottom-coord-rule & s-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "6" ].

;;; Coordination Strategy 7

s7-top-coord-rule := basic-s-top-coord-rule & monopoly-top-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "7" ].

s7-mid-coord-rule := basic-s-mid-coord-rule & monopoly-mid-coord-rule &
  [ SYNSEM.LOCAL.COORD-STRAT "7" ].

s7-bottom-coord-rule := conj-first-bottom-coord-rule & s-bottom-coord-phrase &
  [ SYNSEM.LOCAL.COORD-STRAT "7" ].

;; We treat question particles as complementizers.
;; Here is the lexical type for complementizers.

adj-head-phrase :+ 
  [ SYNSEM [ LOCAL.CAT.MC #mc,
             BARE #bare],	
    HEAD-DTR.SYNSEM [ L-PERIPH na-or--,
                      LOCAL.CAT.MC #mc,
                      BARE #bare ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD.MOD < [ BARE #bare ] > ].

;; SSH 2015-03-17: *张三 哦 哭 了 。
scopal-mod-phrase :+
  [ SYNSEM.INTERJECTED #interjected,
    HEAD-DTR.SYNSEM.PUNCTUATED na-or--,
    NON-HEAD-DTR.SYNSEM.INTERJECTED #interjected ].

;; SSH 2014-12-19: BOUND for blocking [狗 轻轻 [地 [叫 了]].
;; ZZF 2016-2-22: "LIGHT -" to mother to stop rslt rules (which requires "LIGHT +"
adj-head-int-mc := adj-head-int-phrase &
  [ SYNSEM [ LOCAL.CAT [ NONSUBJ #ns,
		       NONCOMP #nc ],
             LIGHT - ],
    HEAD-DTR.SYNSEM [ SPART no-spart,
		      LOCAL.CAT [ HEAD.MEASURE #meas,
				  NONSUBJ #ns,
				  NONCOMP #nc ],
                      BOUND na-or--,
                      BARE - ],
    NON-HEAD-DTR.SYNSEM [ BOUND na-or--,
			  LOCAL.CAT [ HEAD.MEASURE #meas,
				      NONSUBJ #ns,
				      NONCOMP #nc ] ] ].

;; 2016-2-21 ZZF: added phr-synsem to mother. 

adj-head-scop-phrase :+ 
  [ SYNSEM phr-synsem & [ L-PERIPH #lperiph,
	                  R-PERIPH #rperiph ],
    HEAD-DTR.SYNSEM.BOUND na-or--,
    NON-HEAD-DTR.SYNSEM [ L-PERIPH #lperiph,
			  R-PERIPH #rperiph ] ].

alts :+ 
  [ LE-PFV bool ].


; SSH 2014-08-26: For Topic-Comment Constructions 
; (1) This kind of types should reflect on the order of constituents
; in their names. Thus, I changed the name: head-filler-phrase to
; filler-head-phrase.  (2) I do not understand the purpose and
; function of C-CONs-coord-phraseT. Temporily, I remove it.

#|
head-filler-phrase := basic-head-filler-phrase & head-final & 
  [ SYNSEM.LOCAL.CAT [ VAL #val,
               MC #mc ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD verb,
                  VAL #val & [ SUBJ < >,
                           COMPS < >,
                           SPR < >,
                           SPEC < > ],
                  MC #mc ],
                CONT.HOOK #hook ],
    NON-HEAD-DTR.SYNSEM.NON-LOCAL.QUE 0-dlist,
    C-CONs-coord-phraseT.HOOK #hook ].
|#

;; SSH 2015-07-13 : [MC +]
filler-head-phrase := basic-head-filler-phrase & head-final & 
		      topic-comment &
  [ SYNSEM [ L-PERIPH +,
	     LOCAL.CAT [ VAL #val,
			 MC + ] ],
    HEAD-DTR.SYNSEM [ L-PERIPH -,
		      BOUND na-or--,
		      LOCAL [ CAT [ HEAD verb,
				    VAL #val & [ SUBJ < >,
						 COMPS < >,
						 SPR < >,
						 SPEC < > ] ],
			      CONT.HOOK #hook & [ INDEX #clause,
						  CLAUSE-KEY #clause ] ] ],
    NON-HEAD-DTR.SYNSEM [ INTERJECTED na-or--,
			  PUNCTUATED na-or--,
			  LOCAL [ CAT.HEAD noun,
				  CONT.HOOK.INDEX #index ],
			  NON-LOCAL.QUE 0-dlist ],
    C-CONT [ HOOK #hook,
	     RELS <! !>, HCONS <! !>, 
	     ICONS <! topic &
		    [ IARG1 #clause,
                      IARG2 #index ] !> ] ].

;; SSH 2014-09-02: added [MODIFIED] for blocking overgeneration
;; SSH 2014-09-02: added [MC +] for blocking overgeneration ;;zz: MC luk to allow extract from any v clause
extracted-comp-phrase := basic-extracted-comp-phrase & 
  [ SYNSEM [ MODIFIED #modified,
             LOCAL.CAT [ MC +,
                         VAL.COMPS < > ]  ],
    HEAD-DTR.SYNSEM [ MODIFIED #modified,
		      BOUND na-or--,
		      LOCAL [ CAT.HEAD verb,
			      CONT.HOOK #hook ] ],
    C-CONT [ HOOK #hook, RELS <! !>, HCONS <! !>, ICONS <! !> ] ].

;; DPF 2011-06-03 - Given current analysis of relative clauses as containing
;; exactly one extracted element (which is thus relativized), we need subject
;; extr at least for e.g. MRS:53
;; DPF 2011-06-03 - HACK: stamped SPEC < [] > on mother, to avoid immediate
;; filler-head-rule application for embedded clause in "I think dog chase cat".
;; This `works' because the filler-head rule already demands that the hd-dtr
;; have empty SPEC value; note that when an extracted-subj clause is picked
;; up as a complement, the SPEC value is ignored higher up, since the verb
;; selecting the S/NP does not pass up that SPEC value, of course.
;;

;;ZZF FB LMC 2016-4-20 NON-LOCAL.SLASH 0-dlist to avoid applying this after extracted-comp-phrase, but this stops extracted-subj-phrase being applied. So taking out now. Need further discussion with Emily.
extracted-subj-phrase := basic-extracted-subj-phrase & 
  [ SYNSEM [ MODIFIED #modified,
	     LOCAL.CAT [ MC +,
			 VAL.SPEC < [] > ] ], 
    HEAD-DTR.SYNSEM [ MODIFIED #modified,
		      BOUND na-or--,
		      LOCAL [ CAT [ HEAD +vj,
                                    VAL [ SUBJ < [ LOCAL.CAT.NONSUBJ - ] >,
                                          COMPS < > ] ],
			      CONT.HOOK #hook ] ],
    C-CONT [ HOOK #hook, RELS <! !>, HCONS <! !>, ICONS <! !> ] ].

coord-phrase :+ 
  [ SYNSEM.NON-LOCAL.SLASH 0-dlist,
    LCOORD-DTR.SYNSEM.NON-LOCAL.SLASH 0-dlist,
    RCOORD-DTR.SYNSEM.NON-LOCAL.SLASH 0-dlist ].

;; MATRIX REDEFINITION
;; Note: Modified to allow multiple rels 

basic-determiner-lex := norm-hook-lex-item & basic-icons-lex-item & 
  [ SYNSEM [ LOCAL [ CAT [ HEAD det,
			   VAL.SPEC.FIRST.LOCAL.CONT.HOOK [ INDEX #ind,
							    LTOP #larg ] ],
		     CONT.HCONS <! qeq &
				 [ HARG #harg,
				   LARG #larg ] !> ],
	     LKEYS.KEYREL quant-relation &
		   [ ARG0 #ind,
		     RSTR #harg ] ] ].

;; SSH 2014-08-26: MATRIX REDEFINITION
infostr-marking-determiner-lex := basic-determiner-lex.


;; MATRIX REDEFINITION
;; Note: for the following, removed QUE 0-dlist -- question words can function 
;; as direct objects
;;
clause := phrasal.

;; MATRIX REDEFINITION
;; Note: Removed [QUE 0-dlist] from HEAD-DTR, to allow in-situ WH
;; 
basic-non-rel-clause := clause & head-compositional & 
  [ SYNSEM.NON-LOCAL.REL 0-dlist,
    HEAD-DTR.SYNSEM [ LOCAL.CONT.HOOK [ INDEX #index,
                                        ICONS-KEY.IARG1 #index,
                                        CLAUSE-KEY #index ],
                      NON-LOCAL.REL 0-dlist ],
    C-CONT [ RELS <! !>,
             HCONS <! !> ] ].

;; MATRIX REDEFINITION
;; Note: We removed the [QUE 0-dlist] constraint from the NON-HEAD-DTR
;; since Mandarin has in-situ WH-phrases.
;;
basic-head-subj-phrase := head-valence-phrase & binary-headed-phrase &
                          head-compositional & 
  [ SYNSEM phr-synsem & 
           [ LOCAL.CAT [ POSTHEAD +,
                         VAL [ SUBJ < >,
                               COMPS #comps,
                               SPR #spr ] ] ],
    HEAD-DTR.SYNSEM [ BOUND na-or--,
		      LOCAL.CAT.VAL [ SUBJ < #synsem >,
				      COMPS #comps,    
				      SPR #spr ] ],
    NON-HEAD-DTR.SYNSEM #synsem & canonical-synsem &
           [ LOCAL.CAT.VAL [ SUBJ olist,
                             COMPS olist,
                             SPR olist ],
             NON-LOCAL [ SLASH 0-dlist & [ LIST < > ],
                         REL 0-dlist ] ],
    C-CONT [ RELS <! !>, HCONS <! !>, ICONS <! !> ] ].

;; Nouns which cannot take specifiers mark their SPR requirement
;; as OPT +.  Making the non-head daughter OPT - in this rule
;; keeps such nouns out.
;; 
;; Rules for building NPs.  Note that the Matrix uses SPR for
;; the specifier of nouns and SUBJ for the subject (specifier) of verbs.

;; MATRIX REDEFINITION
;; Note: We removed the identification of HOOK on mother and NON-HEAD-DTR,
;; since we need two subtypes of head-specifier phrsae, one whose HOOK
;; is identified with the NON-HEAD-DTR, and one where the HOOK is the same
;; as that of the HD-DTR.
;;

;;We changed the head daughter's comps list to the empty list, rather than olist
#|
basic-head-spec-phrase := head-valence-phrase & phrasal &
              binary-headed-phrase & 
  [ INFLECTED infl-satisfied,
    SYNSEM phr-synsem & [ LOCAL.CAT [ VAL [ SUBJ #subj,
                        COMPS #spcomps,
                        SPR #spr,
                        SPEC #spec ],
                      POSTHEAD #ph ],
              MODIFIED #modif ],
    HEAD-DTR [ INFLECTED infl-satisfied,
               SYNSEM [ LOCAL [ CAT [ HEAD #head,
                                      VAL [ SUBJ #subj,
                                            COMPS <> & #comps,
                                            SPR < #synsem & 
                                                  canonical-synsem . #spr >,
                                            SPEC #spec ],
                                      POSTHEAD #ph ],
                                CONT.HOOK #hdhook ],
                        MODIFIED #hmodif ] ],
    NON-HEAD-DTR.SYNSEM #synsem &
          [ LOCAL [ CAT.VAL [ SPEC < [ LOCAL [ CAT [ HEAD #head,
                             VAL.COMPS #comps ],
                           CONT.HOOK #hdhook ],
                       MODIFIED #hmodif ] >,
                  COMPS #spcomps ],
            CONT.HOOK #hook ],
        MODIFIED #modif ],
    C-CONT [ HOOK #hook,  RELS <! !>, HCONS <! !>, ICONS <! !> ] ].

head-spec-phrase := basic-head-spec-phrase & head-final &
  [ NON-HEAD-DTR.SYNSEM [ LOCAL [ CAT [ VAL.SUBJ < >,
                    HEAD det ],
                  CONT.HOOK #hook ] ],
    C-CONT.HOOK #hook ].

;; Note here, the syntactic head is the semantic head
;; note, we deleted NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < > : this is already specified in the heads
;; 
;;; DPF 21-dec-09 - use head-compositional etc instead...

head-spec-h-sem-phrase := basic-head-spec-phrase & head-final &
  [ SYNSEM.LOCAL.CAT.HEAD.MODIFIABLE +,
    HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD +jrpd & [ MODIFIABLE + ],
                            CONT.HOOK #hook ],
    C-CONT.HOOK #hook ].

; For nominalizer head `de', which must be [HEAD noun], but which is also the
; semantic head.  Cannot easily collapse with either of the other two head-spec
; rules, since the non-head-dtr can be [HEAD det] in the hspec-hs rule where
; the head is a classifier.  FIX someday?
;
head-nom-spec-h-sem-phrase := basic-head-spec-phrase & head-final &
  [ HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD noun,
                CONT.HOOK #hook ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD +vjp,
    C-CONT.HOOK #hook ].
|#


;; SSH 2014-08-22 zhong specific basic-head-spec-phrase 
;; ZZF 2015-9-30 taking out "STYLE robust," as this is preventing sentences from parsing
basic-head-spec-phrase := head-valence-phrase & phrasal &
                          binary-headed-phrase & 
  [ 
    INFLECTED infl-satisfied,
    SYNSEM phr-synsem & [ LOCAL [ CAT [ VAL [ SUBJ #subj,
					      SPR #spr,
					      SPEC #spec ],
					POSTHEAD #ph ],
				  CONT.HOOK.CLAUSE-KEY #clause ],
			  MODIFIED #modif ],
    HEAD-DTR [ INFLECTED infl-satisfied,
               SYNSEM [ R-PERIPH na-or--,
			LOCAL [ CAT [ HEAD #head,
				      VAL [ SUBJ #subj,
					    COMPS <> & #comps,
					    SPR < #synsem & 
						  canonical-synsem . #spr >,
					    SPEC #spec ],
                                      POSTHEAD #ph ],
				CONT.HOOK #hdhook & [ CLAUSE-KEY #clause ] ],
			MODIFIED #hmodif ] ],
    NON-HEAD-DTR.SYNSEM #synsem &
     [ R-PERIPH na-or--,
       LOCAL [ CAT.VAL.SPEC < [ LOCAL [ CAT [ HEAD #head,
					      VAL.COMPS #comps ],
					CONT.HOOK #hdhook ],
				MODIFIED #hmodif ] >,
	       CONT.HOOK.CLAUSE-KEY #clause ],
       MODIFIED #modif ],
    C-CONT [ RELS <! !>, HCONS <! !>, ICONS <! !> ] ].


head-spec-phrase := basic-head-spec-phrase & head-final &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    NON-HEAD-DTR.SYNSEM [ LOCAL [ CAT [ VAL.SUBJ < >,
                    HEAD det ],
                  CONT.HOOK #hook ] ],
    C-CONT.HOOK #hook ].


;; Note here, the syntactic head is the semantic head
;; note, we deleted NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < > : this is already specified in the heads
;; 
;;; DPF 21-dec-09 - use head-compositional etc instead...
;; SSH 2015-04-16 discourse stgatus (definitesness)
; ---------------------------------------
;           | cmn             | yue
; ---------------------------------------
; DEM-CL-N  | uniq-fam-active (definite)
; NUME-CL-N | type-id (indefinite)
; CL-N      | type-id         | active-or-less ((in)definite)
; N         | active-or-less  | type-id 
; ---------------------------------------
head-spec-h-sem-phrase := basic-head-spec-phrase & head-final &
  [ SYNSEM.LOCAL.CAT [ HEAD.MEASURE -,
		       VAL.COMPS #spcomps ],
    HEAD-DTR.SYNSEM [ BOUND na-or--,
                      LOCAL [ CAT.HEAD +jrpd,
			      CONT.HOOK #hook ] ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #spcomps,
    C-CONT.HOOK #hook ].

; For nominalizer head `de', which must be [HEAD noun], but which is also the
; semantic head.  Cannot easily collapse with either of the other two head-spec
; rules, since the non-head-dtr can be [HEAD det] in the hspec-hs rule where
; the head is a classifier.  FIX someday?
;

head-nom-spec-h-sem-phrase := basic-head-spec-phrase & head-final &
  [ SYNSEM.LOCAL.CAT.VAL.COMPS #spcomps,
    HEAD-DTR.SYNSEM.LOCAL [ CAT.HEAD noun,
                CONT.HOOK #hook ],
    NON-HEAD-DTR.SYNSEM [ BOUND na-or--,
			  LOCAL.CAT [ HEAD +vjp,
				      VAL.COMPS #spcomps ] ],
    C-CONT.HOOK #hook ].

;; Bare NP phrase.  Consider modifying the PRED value of the quantifier 
;; relation introduced to match the semantic effect of bare NPs in your 
;; language.

;; MATRIX REDEFINITION
;; Note: we removed the SPEC <> constraint
;;; DPF - motivate? - shouldn't the head at least propagate SPEC to mother?

basic-bare-np-phrase := head-only &
  [ SYNSEM.LOCAL.CAT.VAL [ SPR < >,
                           SUBJ < >,
                           COMPS < > ],
    HEAD-DTR.SYNSEM [ PUNCTUATED na-or--,
	              LOCAL [ CAT.VAL [ SPR < [ LOCAL.CAT.HEAD det,
                                                OPT + ] >,
                                        SUBJ < >,
                                        COMPS olist ],
                              CONT.HOOK [ INDEX #index,
                                          LTOP #larg ] ] ],
    C-CONT [ RELS <! quant-relation &
                   [ LBL #ltop,
                     ARG0 #index,
                     RSTR #harg ] !>,
             HCONS <! qeq & 
                    [ HARG #harg,
                      LARG #larg ] !>,
             ICONS <! !>,
             HOOK [ INDEX #index,
                    LTOP #ltop ] ] ].

bare-np-phrase := basic-bare-np-phrase &
"to push a common noun without a determiner to be NP
<ex>我 吃 苹果
"
  [ SYNSEM [ BARE +,
             LIGHT #light,
	     LOCAL.CAT [ HEAD noun & [ GENERIC - ],
             NONSUBJ #ns ],
         NON-LOCAL.SLASH 0-dlist ],
    HEAD-DTR.SYNSEM [ LIGHT #light,
                      LOCAL [ CAT.NONSUBJ #ns,
			    CONT.HOOK.INDEX.COG-ST activ-or-less ] ],
    C-CONT.RELS <! [ PRED exist_q_rel ] !> ].


;; CL-phrase => nominal phrase
basic-bare-nominal-phrase := unary-phrase &
"[ EMPTY - ] on child node to prevent temporal phrases like 昨天 from being converted from ADP to NP again.
And [ EMPTY + ] on parent node to signal this NP has no head noun.
"
  [ SYNSEM.LOCAL [ CAT [ HEAD noun & [ EMPTY +],
                         VAL [ SPR < [ LOCAL.CAT.HEAD det,
                                       OPT + ] >,
                               SUBJ < >,
                               COMPS < > ],
                         POSTHEAD +,
                         NONSUBJ #ns ],
                   COORD -,
                   CONT.HOOK #hook & [ INDEX.SORT nontime-s ] ],
    ARGS < [ SYNSEM.LOCAL.CAT [ HEAD.EMPTY -,
                                VAL [ SUBJ < >,
                                      SPR olist ],
                                NONSUBJ #ns ] ] >,
    C-CONT [ RELS <! noun-relation &
                   [ PRED generic_n_rel,
                     LBL #ltop,
                     ARG0 #index ] !>,
             HCONS <! !>,
             ICONS <! !>,
             HOOK #hook &
                  [ LTOP #ltop,
                    INDEX #index ] ] ].

bare-nominal-postp-phrase := basic-bare-nominal-phrase &
"pushing DE construction to be NP, including relativing DE and associative DE. DeP should have its COMP fulfilled, thus avoid nominalizing DE alone.
<ex>我 喜欢 很 红 的
<ex>我 喜欢 他 写 的
<ex>我 喜欢 吃 的
<ex>我 的 哭 了
<ex>我　喜欢　那　本　红　的
<ex>我　喜欢　的　是　那　本　红　的
Ideally for ADJ/V + DE, only the slashed DeP should be pushed up to be NP. But adding in this constraint would prevent the rule
from being applied for possessive NP+DE. To be fixed later."
  [ ARGS < [ SYNSEM.LOCAL.CAT [ HEAD postp-nominalizable &
                                     [ MOD < [ LOCAL.CONT.HOOK [ LTOP #ltop,
					                         INDEX #index ] ] > ],
                                VAL.COMPS < > ] ] >,
    C-CONT.HOOK [ LTOP #ltop,
		  INDEX #index ] ].

bare-nominal-det-phrase := basic-bare-nominal-phrase &
"pushing determiners or det+classifier to be NP
<ex>我　喜欢　那　本
<ex>那 是 张三
<ex>我 喜欢 那些
"
  [ ARGS < [ SYNSEM.LOCAL.CAT [ HEAD det,
                                VAL.SPEC < [ LOCAL.CONT.HOOK 
                                             [ LTOP #ltop,
                                               INDEX #index ] ] > ] ] >,
    C-CONT.HOOK [ LTOP #ltop,
		  INDEX #index ] ].

;; SSH 2015-04-21: Generic NPs have an underspecified COG-ST value.
;; [CONT.HOOK.INDEX.COG-ST type-id] is deleted.
generic-np-phrase := basic-bare-np-phrase &
  [ SYNSEM [ LOCAL.CAT [ HEAD noun & [ GENERIC + ],
			 NONCOMP + ],
	     NON-LOCAL.SLASH 0-dlist ],
    HEAD-DTR.SYNSEM [ BARE -, 
		      LOCAL [ CAT.HEAD.CLASSIFIED na-or-- ] ],
    C-CONT.RELS <! [ PRED generic_q_rel ] !> ].

; Restrict head-dtr to non-empty SPR, to avoid spurious ambiguity.
;
;; SSH 2014-04-16 added [CLASSIFIED na-or--]
;; SSH 2014-04-21 noun -> +njd, [NONCOMP +] added for blocking overgeneration.
meas-np-phrase := head-final & head-valence-phrase & phrasal &
  [ SYNSEM.LOCAL.CAT [ NONCOMP +,
		       HEAD [ MEASURE + ],
		       VAL [ SUBJ < >,
			     SPR < >,
			     COMPS < > ] ],
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD num,
                                      VAL.SPR < > ],
                                CONT.HOOK [ LTOP #ltop,
                                            INDEX #nhind ] ],
    HEAD-DTR.SYNSEM lex-synsem & [ BARE -,
				   LOCAL [ CAT [ HEAD +njd & [ GENERIC na-or--,
							       CLASSIFIED na-or-- ],
						 VAL.SPR < [ ] > ],
					   CONT.HOOK [ LTOP #ltop,
						       INDEX #hind & [ COG-ST uniq+fam+act ] ] ] ],
    C-CONT [ HOOK.INDEX #hind,
             RELS <! [ LBL #ltop,
                       PRED measure_x_rel,
                       ARG1 #hind,
                       ARG2 #nhind ],
		     quant-relation &
		     [ PRED exist_q_rel,
		       ARG0 #hind,
		       RSTR #harg ] !>,
             HCONS <! qeq & 
                      [ HARG #harg,
			LARG #ltop ] !>,
             ICONS <! !> ] ].


;; SSH 2014-12-19: 追赶 张三 ！
;; non-asepct & main clause
opt-subj-imperative-phrase := imp-head-opt-subj-phrase &
  [ SYNSEM [ LOCAL.CAT.HEAD verb & [ COP - ],
	     NON-LOCAL.SLASH 0-dlist ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT.MC +,
			    CONT.HOOK.INDEX.E.ASPECT non-aspect ] ].

opt-subj-declarative-phrase := decl-head-opt-subj-phrase &
  [ SYNSEM [ LOCAL.CAT.HEAD +vj,
             NON-LOCAL #non-local ],
    HEAD-DTR [ SYNSEM [ LOCAL [ CAT.MC +,
			        CONT.HOOK.INDEX.E.ASPECT aspect ],
                        NON-LOCAL #non-local ],
               ARG-ST.FIRST.NON-LOCAL [ SLASH 0-dlist,
                                        QUE 0-dlist,
                                        REL 0-dlist ] ] ].

basic-n-n-compound-phrase := head-final &
"[EMPTY -] to stop combining NPs with no head noun, like DeP.
"
  [ SYNSEM [ LOCAL.CAT #cat,
             NON-LOCAL #nonloc ],
    HEAD-DTR.SYNSEM lex-synsem &
                [ LOCAL [ CAT #cat & 
                              [ HEAD noun & 
                                     [ CLASSIFIED na-or--,
                                       EMPTY - ],
                                VAL [ SPR < synsem >,
                                      COMPS < > ] ],
                          CONT.HOOK [ LTOP #ltop,
                                      INDEX #hind ] ],
                  NON-LOCAL #nonloc ],
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD noun & [ EMPTY - ],
                                      VAL.COMPS < >,
                                      POSTHEAD - ],
                                CONT.HOOK [ LTOP #larg,
                                              INDEX #nhind ] ],
    C-CONT [ HOOK [ LTOP #ltop,
            INDEX #hind ],
	     RELS <! quant-relation & [ PRED exist_q_rel,
					ARG0 #nhind,
					RSTR #harg ],
                      arg12-ev-relation & [ LBL #ltop,
                                            PRED compound_p_rel,
                                            ARG1 #hind, 
				            ARG2 #nhind ] !>,
             HCONS <! qeq & [ HARG #harg,
                              LARG #larg ] !>,
             ICONS <! !> ] ].

;; ZZF 2016-9-23: created separately for pronoun+noun.
pronoun-noun-compound-phrase := basic-n-n-compound-phrase &
"Forms a pronoun-noun compound phrase. The head has to be a noun with noun-relation, thus excluding nominalized DE phrases.The non-head-daughter can't be a proper noun or common noun, constrained using LIGHT and SPR. 
<ex>我 朋友 哭 了
<nex>张三 朋友 哭 了
<nex>苹果 朋友 哭 了
<nex>他 解决 了 产品 的 质量 问题
Head noun can't be temporal noun, using nontime-s.
Strictly the head noun should refers to human only, which is to be treated later, 
e.g. adding a HUMAN +/- feature for all nouns"
  [ HEAD-DTR.SYNSEM.LOCAL.CONT [ RELS.LIST.FIRST noun-relation,
                                 HOOK.INDEX.SORT nontime-s],
    NON-HEAD-DTR.SYNSEM [ LIGHT +,
                          LOCAL [ CAT.VAL.SPR < >,                                       
                                  CONT.RELS.LIST.FIRST [ PRED pron_rel] ] ] ].


;; DPF 27-jul-11 - Removed HEAD-DTR..MODIFIED notmod to allow "old dog who 
;; can bark" |一 只 会 叫 的 老 狗|
;;
;; SSH 2014-04-16: added [CLASSIFIED na-or--] to prevent [一 只 猫]
;; from being analyzed as a compound
noun-noun-compound-phrase := basic-n-n-compound-phrase &
"Forms a noun-noun compound phrase
<ex>他 解决 了 质量 问题
<ex>他 解决 了 产品 质量 问题
<ex>他 解决 了 产品 的 质量 问题
<nex>他 解决 了 张三 问题
<nex>他 解决 了 我 问题
For compounds with >2 nouns, we have bracketting ambiguity, e.g. [产品 [质量 问题]] or [[产品 质量] 问题]. 
The rule allows both interpretations, leaving the ambiguity for statistical ranking model to determine later."
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SPR < synsem > ].

#|ZZF: comment out temporarily, not necessary
;; SSH 2014-12-19: phr-synsem is added.
nom-de-noun-compound-phrase := head-final &
  [ SYNSEM phr-synsem &
           [ LOCAL.CAT #cat,
             NON-LOCAL #nonloc ],
    HEAD-DTR.SYNSEM phr-synsem & [ LOCAL [ CAT #cat & 
					       [ HEAD noun,
						 VAL [ COMPS < > ] ],
					   CONT.HOOK [ LTOP #ltop,
						       INDEX #hind ] ],
				   NON-LOCAL #nonloc ],
    NON-HEAD-DTR.SYNSEM.LOCAL [ CAT [ HEAD noun,
                                      VAL [ SPR < anti-synsem >,
                                            COMPS < > ],
                                      POSTHEAD - ],
                                CONT.HOOK [ LTOP #larg,
                                            INDEX #nhind ] ],
    C-CONT [ HOOK [ LTOP #ltop,
            INDEX #hind ],
	     RELS <! quant-relation & [ PRED exist_q_rel,
					ARG0 #nhind,
					RSTR #harg ] !>,
             HCONS <! qeq & [ HARG #harg,
                              LARG #larg ] !>,
             ICONS <! noun-noun & [ IARG1 #hind, 
				    IARG2 #nhind ] !> ] ].
|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Resultative Compounds 
;;; SSH 2015-04-06
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; @phdthesis{lee:13,
;   title={Event Structure and Grammatical Patterns: Resultative Constructions},
;   author={Lee, Leslie},
;   year={2013},
;   school={University of California, San Diego}
; }
;  Type 4, 6, 13 were not introduced in order to reduce overgeneration (they are rarely used).
;  Type 8 can be handled as head-opt-comp-phrase. 
;  Type 9 is redundant to others except for noun incorporation.
;  Instead, I added two more types in which 给 is used as V2 from the following article.
; @article{li:90,
;   title={{On VV Compounds in Chinese}},
;   author={Li, Yafei},
;   journal={Natural Language \& Linguistic Theory},
;   volume={8},
;   number={2},
;   pages={177--207},
;   year={1990},
;   publisher={Springer}
; }
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

rslt-compound-phrase := head-initial &
  [ SYNSEM [ LOCAL.CAT [ HEAD #head,
			 VAL [ SPR #spr,
			       SPEC #spec ],
			 MC luk, 
			 MKG #mkg,
			 HC-LIGHT #hclight, 
			 POSTHEAD #posthead,
			 NONSUBJ #nonsubj ],
	     NON-LOCAL #nonloc ],
    HEAD-DTR.SYNSEM lex-synsem &
                [ BOUND na-or--,
                  LIGHT +,
		  LOCAL [ CAT [ HEAD #head & +vj & [ CHAR.LENGTH one,
						     STATIVE na-or--,
                                                     COP -,
						     AUX - ],				
				VAL [ SPR #spr,
				      SPEC #spec ],
				MC na-or--,
				MKG #mkg,
				HC-LIGHT #hclight, 
				POSTHEAD #posthead,
				NONSUBJ #nonsubj ],
			  CONT [ HOOK [ LTOP #ltop,
					INDEX #arg1 ] ] ],
                  NON-LOCAL #nonloc ],
    NON-HEAD-DTR.SYNSEM lex-synsem &
	        [ LIGHT +,
		  BOUND na-or--,
		  LOCAL [ CAT [ HEAD +vj & [ AUX - ],
				MC na-or-- ],
			  CONT.HOOK.INDEX #arg2 ] ],
    C-CONT [ HOOK [ LTOP #ltop,
		    INDEX #arg1 ],
	     RELS <! !>,
             HCONS <! !>,
	     ICONS <! rslt & [ IARG1 #arg1, 
			       IARG2 #arg2 ] !> ] ].

rslt-x_12-phrase := rslt-compound-phrase & 
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < #subj >,
			   COMPS < #comp > ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < #subj >,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ < #subj >,
					COMPS < #comp > ] ].

rslt-1_1-phrase := rslt-compound-phrase & 
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

rslt-12_1-phrase := rslt-compound-phrase & 
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < [] >,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

subject-oriented-phrase := head-initial & 
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < #subj >,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < #subj > ].

object-oriented-phrase := head-initial & 
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < #comp & [ LOCAL.CONT.HOOK.INDEX.PNG.ANIMACY animate ] >,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < #comp > ].

inverse-oriented-phrase := head-initial & 
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < #subj & [ LOCAL.CONT.HOOK.INDEX.PNG.ANIMACY inanimate ] >,
			   COMPS < #comp & [ LOCAL.CONT.HOOK.INDEX.PNG.ANIMACY animate ] > ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ < #comp >,
				    COMPS < #subj > ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < #comp > ].


rslt-1_12-phrase := rslt-x_12-phrase & subject-oriented-phrase &
"Type 2 (lee:13)
<ex>张三 玩 忘 了 责任
"
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS < > ].

rslt-12_12-phrase := rslt-x_12-phrase & subject-oriented-phrase &
"Type 1 (lee:13)
<ex>张三 下 赢 棋
"
  [ HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #comps,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.COMPS #comps ].


rslt-1_1-sbj-phrase := rslt-1_1-phrase & subject-oriented-phrase &
"Type 10 (lee:13)
<ex>张三 跑 累 了
"
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < #subj >,
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < #subj > ].


rslt-1_1-obj-phrase := rslt-1_1-phrase & object-oriented-phrase &
"Type 5 (lee:13)
<ex>张三 哭 红 了 双眼
"
  [ SYNSEM.LOCAL.CAT.VAL.SUBJ < #subj >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < #subj > ].


rslt-1_1-noshare-phrase := rslt-1_1-phrase & subject-oriented-phrase &
"Type 11 (lee:13)
<ex>双眼 哭 红 了 
"
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < [ LOCAL.CONT.HOOK.INDEX.PNG.ANIMACY inanimate ] >,
			   COMPS < > ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < unexpressed & [ OPT + ] > ].


rslt-12_1-sbj-phrase := rslt-12_1-phrase & subject-oriented-phrase &
"Type 7 (lee:13) (Zhangsan chased Lisi and Zhangsan got tired.)
<ex>张三 追 累 了 李四 
"
  [ SYNSEM.LOCAL.CAT.VAL.COMPS < #comp >,
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ < #subj >,
				    COMPS < #comp > ],
    NON-HEAD-DTR.SYNSEM.LOCAL.CAT.VAL.SUBJ < #subj > ]. 


rslt-12_1-obj-phrase := rslt-12_1-phrase & object-oriented-phrase &
"Type 3 (lee:13) (Zhangsan chased Lisi to the extent of making Lisi tired.)
<ex>张三 追 累 了 李四 
"
  [ SYNSEM.LOCAL.CAT.VAL [ SUBJ < #subj >,
			   COMPS < #comp > ],
    HEAD-DTR.SYNSEM.LOCAL.CAT.VAL [ SUBJ.FIRST #subj,
				    COMPS < #comp >] ].

;; Type 12 (lee:13)
;;这 种 药 吃 死 你
rslt-12_1-inv-phrase := rslt-12_1-phrase & inverse-oriented-phrase.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;; Make temporal NPs into adposition phrases
;; SSH 2015-04-20: [ SUBJ < [] > ] on MOD is deleted:
;; 明天 张三 打 跑 了 李四 
np-adp-phrase := unary-phrase & norm-zero-arg &
"push temporal noun to be prepositional phrase
<ex>他 昨天 来 了
"
  [ SYNSEM.LOCAL.CAT [ HEAD prep & 
                [ EMPTY +,
                  MOD < [ LOCAL intersective-mod &
                        [ CAT [ HEAD verb,
                            VAL [ COMPS < > ] ],
                          CONT.HOOK [ LTOP #ltop,
                              INDEX #modind ] ]]> ],
               VAL [ SPR < >,
                 SUBJ < >,
                 COMPS < > ] ],
    ARGS < [ SYNSEM.LOCAL [ CAT [ HEAD noun,
                                  NONCOMP -,
                                  VAL.SPR < > ],
                CONT.HOOK.INDEX #nind & [ SORT time-s,
                              SPECI - ] ] ] >,
    C-CONT [ HOOK [ LTOP #ltop,
            INDEX #index,
            XARG #modind ],
         RELS <! arg12-ev-relation &
           [ LBL #ltop,
             PRED time_p_rel,
             ARG0 #index,
             ARG1 #modind,
             ARG2 #nind ] !>,
         HCONS <! !>,
         ICONS <! !> ] ].

;; WWJ 2014-04-07: to block adj-not-adj prep-not-prep 
;; SSH 2015-04-08: to block overgeneration, [ASPECTED +-or--] is added.
;; SSH 2015-04-12: verb -> +vp
head-opt-comp-phrase := basic-head-opt-comp-phrase &
  [ SYNSEM phr-synsem, 
    HEAD-DTR.SYNSEM [ ASPECTED +-or--,
		      LOCAL.CAT.HEAD +vp ] ].

; for sentential subjects
sent-subj-phrase := head-valence-phrase & head-only &
  [ SYNSEM [ LOCAL.CAT.VAL [ SUBJ < [ LOCAL [ CAT [ HEAD +vjp,
                            VAL [ SUBJ < >,
                              SPR < >,
                              COMPS < > ] ],
                          CONT.HOOK.LTOP #sltop ] ] >,
                 SPR < >,
                 COMPS < > ],
	     LIGHT - ],
    HEAD-DTR.SYNSEM.LOCAL [ CAT [ VAL [ SUBJ < [ LOCAL.CAT.HEAD noun ] >,
                    COMPS olist ],
                  MC na ],
                CONT.HOOK [ LTOP #ltop,
                    INDEX #index,
                    XARG #xarg ] ],
    C-CONT [ HOOK [ LTOP #ltop,
            INDEX #index ],
         RELS <! !>,
         ICONS <! !>,
         HCONS <! qeq & [ HARG #xarg,
                  LARG #sltop ] !> ] ].


;; MATRIX change: promoted SF feature from event-only to individual,
;; in order to simplify allowing sentential subjects while still excluding
;; imperatives
individual :+
  [ SF iforce ].

;; MATRIX addition: Need to distinguish non-coordinated entities

non-coord-index := event-or-ref-index.
non-coord-event := non-coord-index & event.
non-coord-ref-ind := non-coord-index & ref-ind.

;; Semantic sorts, initially just to distinguish temporal and non-temporal Ns

time-s := semsort.
nontime-s := semsort.

;; MATRIX redefinition: Adopted GTOP of modern Matrix, but also relaxed
;; constraint on XARG to allow for sentential subjects (with handle as XARG).
;; SSH 2015-04-30: SPEAKER-KEY and HEARER-KEY for honorification
hook := avm &
  [ GTOP handle,
    LTOP handle,
    INDEX individual,
    XARG semarg,
    ICONS-KEY icons,
    CLAUSE-KEY event,
    SPEAKER-KEY ref-ind, 
    HEARER-KEY ref-ind ].


basic-head-opt-subj-phrase :+ 
  [ HEAD-DTR.SYNSEM.BOUND na-or-- ].

;; MATRIX redefinition, to allow noun heads to discharge optional complements
;;
basic-head-opt-comp-phrase := head-valence-phrase & head-only &
                              head-compositional &
  [ INFLECTED #infl,
    SYNSEM canonical-synsem &
       [ LOCAL.CAT [ VAL [ SUBJ #subj,
                           COMPS #comps,
                           SPR #spr,
                           SPEC #spec ],
                     MC #mc,
                     POSTHEAD #ph ],
         MODIFIED #mod ],
    HEAD-DTR [ INFLECTED #infl & infl-satisfied,
	       SYNSEM [ BOUND na-or--,
			LOCAL [ CAT [ VAL [ SUBJ #subj,
                                            COMPS < unexpressed &
                                                    [ OPT +,
                                                      OPT-CS #def,
                                                      LOCAL.CONT.HOOK [ INDEX #index & [ COG-ST #def ],
                                                                        ICONS-KEY #ikey,
                                                                        CLAUSE-KEY #ckey ] ] . #comps >,
                                            SPR #spr,
                                            SPEC #spec ],
                                      MC #mc,
                                      POSTHEAD #ph ],
                                CONT.HOOK.INDEX individual ],
                        MODIFIED #mod ] ],
    C-CONT [ RELS <! !>,
             HCONS <! !>,
             ICONS <! #ikey & non-focus & [ IARG1 #ckey,
                                            IARG2 #index ] !> ] ].


; head-gerundive-phrase := head-only &
;   [ SYNSEM canonical-synsem & 
; 	   [ LOCAL.CAT.HEAD.MOD < [] > ],
;     HEAD-DTR.SYNSEM.LOCAL.CAT.HEAD verb ].


; 着了过 aspect markers & sentence final 了 & sentence final question particle 
basic-comp-marker-phrase := head-valence-phrase & head-compositional & basic-binary-headed-phrase &
  [ STYLE #style,
    SYNSEM phr-synsem & [ L-PERIPH #lperiph,
			  R-PERIPH #rperiph,
			  PUNCTUATED #punctuated,
			  PAREN #paren,
			  INTERJECTED #interjected,
			  SPART #spart,
			  LOCAL.CAT [ VAL [ SUBJ #subj,
					    COMPS #comps,
					    SPR #spr,
					    SPEC #spec ],
				      POSTHEAD #ph ] ],
    HEAD-DTR.SYNSEM #synsem & [ L-PERIPH #lperiph,
				R-PERIPH #rperiph,
				PUNCTUATED na-or--,
				POSTCOMP na-or--,
				INTERJECTED #interjected,
				LOCAL [ CAT [ VAL [ SUBJ #subj,
						    COMPS #comps,
						    SPR #spr,
						    SPEC #spec ],
					      POSTHEAD #ph ] ] ],
    NON-HEAD-DTR [ STYLE #style,
		   SYNSEM [ L-PERIPH #lperiph,
			    R-PERIPH #rperiph,
			    PUNCTUATED #punctuated,
			    PAREN #paren,
			    SPART #spart,
			    LOCAL.CAT [ HEAD marker-or-punct,
					VAL.COMPS < #synsem > ] ] ],
    C-CONT [ RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ] ].

comp-marker-phrase := basic-comp-marker-phrase & marker-final-phrase & head-initial & 
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT.POSTHEAD na-or-+ ].
marker-comp-phrase := basic-comp-marker-phrase & marker-initial-phrase & head-final &
  [ NON-HEAD-DTR.SYNSEM.LOCAL.CAT [ POSTHEAD na-or-- ] ].

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SSH 2015-04-30 - utterance for dialogue constraints such as honorifications.
utterance-phrase := head-valence-phrase & head-only &
		    head-compositional &
  [ SYNSEM [ UTTERED +,
	     L-PERIPH +,
	     R-PERIPH +,
	     LOCAL local & [ CAT.VAL #val,
			     CONT.HOOK [ SPEAKER-KEY #speaker,
					 HEARER-KEY #hearer ],
			     CTXT ctxt & [ C-INDICES [ SPEAKER #speaker,
						       HEARER #hearer ] ] ] ],
    HEAD-DTR phrase & [ SYNSEM [ UTTERED -,
				 BOUND -,
				 LOCAL [ COORD -,
					 CAT [ VAL [ SUBJ < >,
						     COMPS < > ],
					       MC +,
					       HEAD +vjrpc &
						   [ FORM finite ],
					       VAL #val ],
					 CONT.HOOK [ INDEX #index,
						     LTOP #ltop ] ],
				 NON-LOCAL.SLASH 0-dlist ] ],
    C-CONT [ HOOK [ INDEX #index,
                    LTOP #ltop ],
	     RELS <! !>, 
	     HCONS <! !>,
	     ICONS <! addressor & [ IARG1 #speaker,
				    IARG2 #index ], 
		      addressee & [ IARG1 #hearer,
				    IARG2 #index ] !> ] ].

lex-item :+ [ SYNSEM.UTTERED na ].
coord-phrase :+ 
  [ SYNSEM.UTTERED -,
    LCOORD-DTR.SYNSEM.UTTERED na-or--, 
    RCOORD-DTR.SYNSEM.UTTERED na-or-- ].
extracted-comp-phrase :+
  [ SYNSEM.UTTERED -,
    HEAD-DTR.SYNSEM.UTTERED na-or-- ].
extracted-subj-phrase :+ 
  [ SYNSEM.UTTERED -,
    HEAD-DTR.SYNSEM.UTTERED na-or-- ].
opt-subj-imperative-phrase :+ 
  [ SYNSEM.UTTERED -,
    HEAD-DTR.SYNSEM.UTTERED na-or-- ].
head-opt-comp-phrase :+
  [ SYNSEM.UTTERED -,
    HEAD-DTR.SYNSEM.UTTERED na-or-- ].
basic-binary-phrase :+ 
  [ SYNSEM [ UTTERED -,
	     LOCAL.CONT.HOOK [ SPEAKER-KEY #skey,
			       HEARER-KEY #hkey ] ],
    ARGS < [ SYNSEM [ UTTERED na-or--,
		      LOCAL.CONT.HOOK [ SPEAKER-KEY #skey,
					HEARER-KEY #hkey ] ] ],
	   [ SYNSEM [ UTTERED na-or--,
		      LOCAL.CONT.HOOK [ SPEAKER-KEY #skey,
					HEARER-KEY #hkey ] ] ] > ]. 
unary-phrase :+
  [ SYNSEM.LOCAL.CONT.HOOK [ SPEAKER-KEY #skey,
			     HEARER-KEY #hkey ],
    ARGS < [ SYNSEM.LOCAL.CONT.HOOK [ SPEAKER-KEY #skey,
				      HEARER-KEY #hkey ] ] > ]. 

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; DPF 2014-08-01 - Added unary and binary bridging rules to accommodate robust
;; full-forest treebanking.  The strategy is to pump each normal edge in the
;; chart to a "bridge head" edge via the unary rule, and then combine two
;; adjacent such bridge-head edges using the binary rule.  This strategy,
;; proposed by Woodley Packard, results in a mere doubling of the number of
;; edges in each cell of the chart, rather than the square of the number of
;; normal edges that resulted from trying just a binary bridging rule that
;; accepted either bridge or normal edges.
;;

bridge-head := head-min &
  [ BRIDGED luk ].

bridge-binary-phrase := basic-binary-phrase &
  [ SYNSEM [ LOCAL [ CAT [ HEAD bridge-head & [ BRIDGED + ],
                           VAL [ SUBJ < >,
                                 SPR < >,
                                 COMPS < > ] ] ],
             NON-LOCAL non-local-none ],
    C-CONT [ HOOK [ LTOP #lbl, INDEX #arg0 ],
	     RELS <! [ LBL #lbl,
		       PRED bridge_x_rel,
		       ARG0 #arg0,
		       ARG1 #ind,
		       ARG2 #rind ] !>,
             HCONS <! !>,
	     ICONS <! !> ],
    ARGS < [ SYNSEM.LOCAL [ CAT.HEAD bridge-head & [ BRIDGED - ],
			    CONT.HOOK.INDEX #ind ] ],
           [ SYNSEM.LOCAL [ CAT.HEAD bridge-head,
			    CONT.HOOK.INDEX #rind ] ] > ].

bridge-unary-phrase := basic-unary-phrase &
  [ SYNSEM [ LOCAL [ CAT [ HEAD bridge-head,
                           VAL [ SUBJ < >,
                                 SPR < >,
                                 COMPS < > ] ] ],
             NON-LOCAL non-local-none ],
    C-CONT [ HOOK #hook,
	     RELS <! !>,
             HCONS <! !>,
	     ICONS <! !> ],
    ARGS < [ SYNSEM.LOCAL [ CAT.HEAD head,
			    CONT.HOOK #hook ] ] > ].

